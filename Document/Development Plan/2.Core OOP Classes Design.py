#Core OOP Classes Design

"""
- ในขั้นตอนนี้ เราจะสร้าง "พิมพ์เขียว" สำหรับวัตถุต่างๆ ในเกม ได้แก่ GameObject(พิมพ์เขียวแม่แบบ), 
  Player(ตัวละครผู้เล่น) และ Obstacle(สิ่งกีดขวาง) นี่คือหัวใจของการแสดงแนวคิดเชิงวัตถุ (OOP) ให้กับอาจารย์
- และเราจะสร้างคลาส Manager และ State ทั้งหมด 
- สร้างไฟล์ใหม่ 3 ไฟล์ คือ GameObject.java, Player.java
? ไฟล์
@ folder entities - สิ่งที่อยู่ในเกม มีพฤติกรรมหรือสถานะได้
* 1. GameObject.java
- คลาสนี้เป็น Abstract Class หรือ "คลาสแม่แบบนามธรรม" มันกำหนดว่าวัตถุทุกชิ้นในเกมของเรา ต้องมี อะไรบ้าง
 (ตำแหน่ง, ขนาด) และ ต้องทำ อะไรได้บ้าง (update และ draw) แต่ยังไม่ลงรายละเอียดว่าทำอย่างไร
* 1.1 Player.java
- คลาสนี้คือตัวละครของผู้เล่น จะสืบทอด (extends) คุณสมบัติและเมธอดมาจาก GameObject แล้วเพิ่มรายละเอียด
  เฉพาะของตัวเองเข้าไป เช่น พลังชีวิต (HP)
* 1.2 Obstacle.java
- คลาสนี้จะเป็นคลาสแม่แบบสำหรับ สิ่งกีดขวางทุกชนิด มันจะสืบทอดมาจาก GameObject และเพิ่ม Logic 
  การเคลื่อนที่จากขวามาซ้าย ซึ่งเป็นพฤติกรรมร่วมกันของสิ่งกีดขวางทุกชิ้น
* 1.2.1 Rock.java
- นี่คือคลาสของสิ่งกีดขวางจริงๆ ชิ้นแรกของเรา คือ "ก้อนหิน" ซึ่งจะสืบทอดมาจาก Obstacle
* 1.2.2 Bush.java
- หน้าที่: เป็นนักแสดง "พุ่มไม้"
- การทำงาน: เหมือนกับ Rock ทุกอย่าง แค่หน้าตาและการวาดผลต่างกัน นี่คือพลังของ Polymorphism!
@ folder manager - ทีมงานผู้จัดการ
- ต่อไปคือทีมงาน "หัวหน้าแผนก" ที่ได้รับคำสั่งจากผู้กำกับ (PlayingState) อีกที
* 1. EntityManager.java
- หน้าที่: เป็น "ผู้จัดการนักแสดง" (Entity Manager) มีหน้าที่ดูแลนักแสดงทุกคนในฉาก (ทั้ง Player และ 
  Obstacles)
- การทำงาน: คลาสนี้จะเก็บ Player และ List ของ Obstacles ไว้ เมื่อถูกสั่งให้ update หรือ draw 
  มันจะไปไล่สั่งนักแสดงทุกคนให้ทำงานของตัวเอง
* 2. ObstacleManager.java
- หน้าที่: เป็น "ผู้จัดการฝ่ายสร้างสรรค์" มีหน้าที่เดียวคือ "สร้าง" สิ่งกีดขวางใหม่ๆ ออกมา
- การทำงาน: มี Logic ในการจับเวลา (spawnTimer) เมื่อถึงเวลาที่กำหนด จะสุ่มสร้างสิ่งกีดขวาง (ตอนนี้มี 
  Rock กับ Bush) แล้วส่งไปให้ EntityManager ดูแลต่อ
@ folder gamestates - ผู้กำกับของเกม
* 1. GameState.java
- หน้าที่: เป็นป้ายบอกสถานะของเกมเฉยๆ (เหมือนป้ายบอกชื่อซีนในกองถ่าย)
- การทำงาน: ใช้ enum ซึ่งเป็นวิธีที่ปลอดภัยและชัดเจนที่สุดในการกำหนดสถานะที่มีจำนวนจำกัด
* 2. State.java
- หน้าที่: เป็น "พิมพ์เขียวของผู้กำกับ" (Abstract Class) ที่บอกว่าผู้กำกับทุกคนต้องมี 2 หน้าที่หลักคือ update 
  (สั่งให้นักแสดงเคลื่อนไหว) และ draw (สั่งให้ทีมงานวาดฉาก)
- การทำงาน: บังคับให้คลาสลูก (เช่น PlayingState) ต้องไปเขียนโค้ดสำหรับ update() และ draw() เอง
* 2.1 PlayingState.java
- หน้าที่: เป็น "ผู้กำกับของฉากเล่นเกม" ตัวจริงเสียงจริง
- การทำงาน: คลาสนี้จะสร้างและควบคุมเหล่า "ผู้จัดการ" (Managers) ทั้งหลาย เมื่อถึงเวลา update หรือ draw 
  มันจะตะโกนสั่งให้ผู้จัดการทำงานต่ออีกที

? คำอธิบาย
@ 1. Abstraction (ความเป็นนามธรรม):
- เราสร้าง GameObject เป็นคลาสนามธรรม (Abstract Class) เพื่อกำหนด "โครงสร้างร่วม" ว่าวัตถุในเกมต้อง
  ทำอะไรได้บ้าง (update, draw) โดยไม่สนว่า "ทำอย่างไร"
- เปรียบเทียบ: เหมือนการบอกว่า "รถยนต์ทุกคันต้องขับเคลื่อนได้และมีประตู" แต่ยังไม่เจาะจงว่าเป็นรถเก๋งหรือรถกระบะ
@ 2. Inheritance (การสืบทอด):
- คลาส Player extends (สืบทอด) มาจาก GameObject ทำให้ Player ได้รับคุณสมบัติ 
  (x, y, width, height) และโครงสร้างเมธอด (update, draw) มาโดยอัตโนมัติ ช่วยลดการเขียนโค้ดซ้ำซ้อน
- เปรียบเทียบ: "รถเก๋ง" เป็น "รถยนต์" ประเภทหนึ่ง จึงมีคุณสมบัติพื้นฐานของรถยนต์ครบถ้วน และอาจมีคุณสมบัติพิเศษเพิ่มเข้ามา
@ 3. Encapsulation (การห่อหุ้มข้อมูล):
- ในคลาส Player, เราประกาศ private int hp; เพื่อป้องกันไม่ให้คลาสอื่นมาแก้ไขค่า HP ได้โดยตรง 
  การจะลดค่า HP ต้องทำผ่านเมธอด takeDamage() เท่านั้น
- เปรียบเทียบ: เหมือนแผงควบคุมรถยนต์ เราเหยียบคันเร่ง (เรียกเมธอด) เพื่อเพิ่มความเร็ว โดยไม่ต้องไปยุ่งกับกลไก
  เครื่องยนต์ (ตัวแปร) โดยตรง
"""